layout: post    
category : bigdata
tags : [cloud,datalake,thought]
title:  Big Data Research Note - Cloud LakeHouse Best Practice

----------------------------------------------------------------------------------------------------------------

## 大数据研究-大数据Cloud LakeHouse技术应用实践2023

## 写在前面

作者：振策-阿里云计算平台产品解决方案

当湖仓一体成为大数据行业主流, 在这些名词越来越多的出现在各行各业数字化转型的关键活动中。此文仅从大数据产品商业化从业者的视角来探讨与分析大数据领域的存算分离演进过程，核心价值，与相关所产生的蓬勃技术生态。内容来自阿里云计算平台大数据技术商业化思考与实践，与大家共同探讨。

## 1.[趋势]当湖仓一体成为行业共识需求

## 2.[源起]LakeHouse的业务核心价值

从数据湖到数据湖仓再到DataFabric

## 3.[流派]LakeHouse主要技术流派的背后

Iceberg

1.2.1 数据存储、计算引擎插件化
Iceberg 提供一个开放通用的表格式（Table Format）实现方案，不和特定的数据存储、计算引擎绑定。目前大数据领域的常见数据存储（HDFS、S3…），计算引擎（Flink、Spark…）都可以接入 Iceberg。

在生产环境中，可选择不同的组件搭使用。甚至可以不通过计算引擎，直接读取存在文件系统上的数据。

1.2.2 实时流批一体
Iceberg 上游组件将数据写入完成后，下游组件及时可读，可查询。可以满足实时场景。并且 Iceberg 同时提供了流/批读接口、流/批写接口。可以在同一个流程里，同时处理流数据和批数据，大大简化了ETL链路。

1.2.3 数据表演化（Table Evolution）
Iceberg 可以通过 SQL 的方式进行表级别模式演进。进行这些操作的时候，代价极低。不存在读出数据重新写入或者迁移数据这种费时费力的操作。

比如在常用的 Hive 中，如果我们需要把一个按天分区的表，改成按小时分区。此时，不能再原表之上直接修改，只能新建一个按小时分区的表，然后再把数据 Insert 到新的小时分区表。而且，即使我们通过 Rename 的命令把新表的名字改为原表，使用原表的上次层应用，也可能由于分区字段修改，导致需要修改 SQL，这样花费的经历是非常繁琐的。

1.2.4 模式演化（Schema Evolution）
Iceberg 支持下面几种模式演化：

ADD：向表或者嵌套结构增加新列

Drop：从表中或者嵌套结构中移除一列

Rename：重命名表中或者嵌套结构中的一列

Update：将复杂结构(struct, map<key, value>,list)中的基本类型扩展类型长度, 比如 tinyint 修改成 int.

Reorder：改变列或者嵌套结构中字段的排列顺序

Iceberg 保证模式演化（Schema Evolution）是没有副作用的独立操作流程，一个元数据操作, 不会涉及到重写数据文件的过程。具体的如下:

增加列时候，不会从另外一个列中读取已存在的的数据

删除列或者嵌套结构中字段的时候，不会改变任何其他列的值

更新列或者嵌套结构中字段的时候，不会改变任何其他列的值

改变列列或者嵌套结构中字段顺序的时候，不会改变相关联的值

在表中，Iceberg 使用唯一 ID 来定位每一列的信息。新增一个列的时候，会新分配给它一个唯一 ID，并且绝对不会使用已经被使用的ID。

使用名称或者位置信息来定位列的, 都会存在一些问题，比如使用名称的话，名称可能会重复, 使用位置的话，不能修改顺序并且废弃的字段也不能删除。

1.2.5 分区演化（Partition Evolution）
Iceberg 可以在一个已存在的表上直接修改，因为 Iceberg 的查询流程并不和分区信息直接关联。

当我们改变一个表的分区策略时，对应修改分区之前的数据不会改变，依然会采用老的分区策略，新的数据会采用新的分区策略，也就是说同一个表会有两种分区策略，旧数据采用旧分区策略，新数据采用新新分区策略，在元数据里两种分区策略相互独立，不重合。

在查询数据的时候，如果存在跨分区策略的情况，则会解析成两个不同执行计划，如 Iceberg 官网提供图所示：



图中 booking_table 表 2008 年按月分区，进入 2009年 后改为按天分区，这两中分区策略共存于该表中。

借助 Iceberg 的隐藏分区（Hidden Partition），在写 SQL 查询的时候，不需要在 SQL 中特别指定分区过滤条件，Iceberg 会自动分区，过滤掉不需要的数据。

Iceberg 分区演化操作同样是一个元数据操作， 不会重写数据文件。

1.2.6 列顺序演化（Sort Order Evolution）
Iceberg 可以在一个已经存在的表上修改排序策略。修改了排序策略之后，旧数据依旧采用老排序策略不变。往Iceberg里写数据的计算引擎总是会选择最新的排序策略，但是当排序的代价极其高昂的时候, 就不进行排序了。

1.2.7 隐藏分区（Hidden Partition）
Iceberg 的分区信息并不需要人工维护，它可以被隐藏起来。不同于其他类似 Hive 的分区策略，Iceberg 的分区字段/策略（通过某一个字段计算出来），可以不是表的字段和表数据存储目录也没有关系。在建表或者修改分区策略之后，新的数据会自动计算所属于的分区。在查询的时候同样不用关心表的分区是什么字段/策略，只需要关注业务逻辑，Iceberg 会自动过滤不需要的分区数据。

正是由于 Iceberg 的分区信息和表数据存储目录是独立的，使得 Iceberg 的表分区可以被修改，而且不涉及到数据迁移。

1.2.8 时间旅行查询（Time Travel）
Iceberg 提供了查询表历史某一时间点数据镜像（snapshot）的能力。通过该特性可以将最新的SQL逻辑，应用到历史数据上。

1.2.9 支持事务（ACID）
Iceberg 通过提供事务（ACID）的机制，使其具备了 upsert 的能力并且使得边写边读成为可能，从而数据可以更快的被下游组件消费。通过事务保证了下游组件只能消费已 commit 的数据，而不会读到部分甚至未提交的数据。

1.2.10 基于乐观锁的并发支持
Iceberg 基于乐观锁提供了多个程序并发写入的能力并且保证数据线性一致。

1.2.11 文件级数据剪裁
Iceberg 的元数据里面提供了每个数据文件的一些统计信息，比如最大值，最小值，Count 计数等等。因此，查询 SQL 的过滤条件除了常规的分区，列过滤，甚至可以下推到文件级别，大大加快了查询效率。

Paimon

ODPS ACID2.0


## 4.[关键]LakeHouse的技术评估与应用



## 5.[产品演进]LakeHouse的产品发展演进

云器科技

## 6.[实践]LakeHouse的大规模产品商业实践



## 7.[总结]LakeHouse成为大数据产品标配能力





